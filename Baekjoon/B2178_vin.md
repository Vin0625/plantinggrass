## 문제
N×M크기의 배열로 표현되는 미로가 있다.

| 1 | 0 | 1 | 1 | 1 | 1 |
| --- | --- | --- | --- | --- | --- |
| 1 | 0 | 1 | 0 | 1 | 0 |
| 1 | 0 | 1 | 0 | 1 | 1 |
| 1 | 1 | 1 | 0 | 1 | 1 |

미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.

위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.
## 조건
1. 두 정수 N ,M을 입력받음
2. 다음줄부터 NxM크기의 미로를 입력받음
3. (0,0)에서 (N,M)까지의 최단거리를 출력
## 풀이
1. 두 정수 N, M을 입력받는다.
2. 세로가 N , 가로가 M 인 미로를 입력받는다.
3. 단 미로입력시 붙여서 입력받았기 때문에 숫자 하나하나로 나누어 미로에 적용한다.
4. 너비우선탐색(BFS)을 이용 최단거리를 구한다.
5. 최단거리를 출력한다.

이 문제는 최단거리를 구하는 문제이기때문에 특정위치에 도달했을때 바로 해답이 나오는 BFS가 
DFS(깊이우선탐색)보다 유리하다.

BFS를 간단히 설명하면 선택된 노드와 인접한 노드를 방문하여 queue에 집어넣고 방문 여부를 체크하면서 그래프를 탐색하는 방법인데 이 문제에서는 방문여부를 int형 배열로 설정한뒤 그곳까지의 거리를 저장하는 식으로 변형하여 사용하였다.

개인적으로 testcase를 돌릴때 문제가 없었는데 백준에 정답을 제출했을때는 계속 틀렸습니다가 나왔었다.

그 이유는 컴파일러마다 int 형 배열을 값을 설정하지 않고 초기화 할시 0으로 초기화해주는 컴파일러가 있고, 
그렇지 않은 컴파일러가 있는데  
내가 쓰는 컴파일러는 위치에 상관없이 0으로 초기화해주고
백준에서 사용하는 컴파일러는 전역변수인 경우에만 0으로 초기화해줘 

int graph[100][100]; 인 상태로
제출해 오답이 계속 나왔다. 

확실하게 필요한 값을 초기화 해주는 습관을 가지자
## 전체 코드
```cpp
#include <iostream>
#include <queue>

using namespace std;

int main(){
    int N,M;
    string num;
    int graph[100][100]={0};
    int visit[100][100]={0};
    int movex[4]={-1,1,0,0};
    int movey[4]={0,0,-1,1};
    queue<pair<int,int> > q;

    cin>>N>>M;
    for(int i=0;i<N;i++){
        cin>>num;
        for(int j=0;j<M;j++){
            graph[i][j]=num[j]-'0';   
        }
    }
    q.push(make_pair(0,0));
    visit[0][0]=1;

    while (!q.empty())
    {
        int y=q.front().first;
        int x=q.front().second;
        q.pop();

        for(int i=0;i<4;i++){
            int nextx=x+movex[i];
            int nexty=y+movey[i];

            if(0<=nextx&&nextx<M&&0<=nexty&&nexty<N&&graph[nexty][nextx]==1&&visit[nexty][nextx]==0){
                visit[nexty][nextx]=visit[y][x]+1;
                q.push(make_pair(nexty,nextx));
            }
        }
    }
    
    cout<<visit[N-1][M-1];

}
```